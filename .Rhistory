vcf_path = basename(vcf_path)
meta_info = list(vcf_path =  ,
IonReporter = list(AnalysisName = analysis_name,
fileDate = pull_comment_value(comment_section,
stringoi = 'fileDate'),
fileUTCtime = pull_comment_value(comment_section,
stringoi = 'fileUTCtime'),
Software_version = pull_comment_value(comment_section,
stringoi = 'IonReporterSoftwareVersion'),
Export_version = pull_comment_value(comment_section,
stringoi = 'IonReporterExportVersion'),
reference = pull_comment_value(comment_section,
stringoi = 'reference'),
Workflow_version = pull_comment_value(comment_section,
stringoi = 'IonReporterWorkflowVersion'),
WorkflowName = pull_comment_value(comment_section,
stringoi = 'IonReporterWorkflowName')),
SampleInfo = list(disease = pull_comment_value(comment_section,
stringoi = 'sampleDiseaseType'),
tumor_cellularity_manual = pull_comment_value(comment_section,
stringoi = 'manually_input_percent_tumor_cellularity'),
tumor_cellularity_calculated = pull_comment_value(comment_section,
stringoi = 'calculated_tumor_cellularity')),
SequencingQC = list(percent_aligned_reads = pull_comment_value(comment_section,
stringoi = 'percent_aligned_reads'),
percent_non_zero_amplicons = pull_comment_value(comment_section,
stringoi = 'percent_non_zero_amplicons'),
total_read_count = pull_comment_value(comment_section, stringoi = 'total_read_count'),
median_reads_per_amplicon = pull_comment_value(comment_section,
stringoi = 'median_reads_per_amplicon'),
MAPD = pull_comment_value(comment_section,
stringoi = 'mapd'),
deamination_metric = pull_comment_value(comment_section,
stringoi = 'deamination_metric'))
)
return(meta_info)
}
filepaths
as.data.frame(filepaths)
names(filepaths)
unname(filepaths)
unlist(unname(filepaths))
data.frame(file = names(filepaths),
filepath  = unlist(unname(filepaths)))
filepath_df = data.frame(file = names(filepaths),
filepath  = unlist(unname(filepaths)))
readr::write_tsv(filepath_df)
#' Generate paths for output files based on vcfpath
#'
#' @param vcfpath
#'
#' @return
#' @export
#'
#' @examples
generate_paths = function(vcfpath){
analysis_name = aggregate_META_information(vcf_comment_section(vcfpath))
analysis_name = analysis_name$IonReporter$AnalysisName
analysis_name = stringr::str_remove(analysis_name, pattern=" ")
vcfdir = dirname(vcfpath)
path_parsed_output = paste0(vcfdir, "/", analysis_name, "_parsed_output")
if(!dir.exists(path_parsed_output)){
dir.create(path_parsed_output)
}
path_file_info = paste0(path_parsed_output, '/file_info.yaml')
path_file_snv = paste0(path_parsed_output, '/snv.txt')
path_file_complete = paste0(path_parsed_output, '/complete.txt')
path_file_cnv = paste0(path_parsed_output, '/cnv.txt')
path_file_fusions = paste0(path_parsed_output, '/fusions.txt')
filepaths = paste0(path_parsed_output, '/filepaths.txt')
return(list(path_file_info = path_file_info,
path_file_snv = path_file_snv,
path_file_cnv = path_file_cnv,
path_file_fusions = path_file_fusions,
path_file_complete = path_file_complete,
path_filepath = filepaths))
}
## Retrieve dirname and generate filepaths
filepaths = generate_paths(vcfpath = vcfpath)
filepaths
filepaths
unname(filepaths)
unlist(unname(filepaths))
sapply(unlist(unname(filepaths)), file.exists)
## Read in file
vcf = VCFparse::readVCF(vcfpath)
# Parse FUNC
if(nrow(vcf) > 0){
vcf = combine_orig_with_FUNC_extracts(vcf)
}
## remove double columns
vcf =  dplyr::select(vcf, -contains(".1"))
vcf =  dplyr::select(vcf, -FUNC)
# Generate tables
vcf$variant_type = gsub("[^[:alnum:] ]", "", vcf$variant_type)
vcf$protein = gsub("\\[|\\]", "", vcf$protein)
vcf$transcript = gsub("\\[|\\]", "", vcf$transcript)
vcf = dplyr::relocate(vcf, rowid)
# SNV table
snv = dplyr::filter(vcf, variant_type != 'synonymous' & alt != "<CNV>")
## Remove zero AF entries, especially important for Genexus
if("AF" %in% colnames(snv)){
snv = dplyr::filter(snv, AF != 0)
}
snv = dplyr::relocate(snv, rowid)
# CNV entries only
cnv_rows = dplyr::filter(vcf, alt == "<CNV>")
if(nrow(cnv_rows) > 0){
cnv_rows = cnv_parse(cnv_rows)
cnv_rows = dplyr::select(cnv_rows, -origPos)
cnv_rows = dplyr::arrange(cnv_rows, desc(RAW_CN))
}
# COMMENT SECTION
cm = vcf_comment_section(vcfpath = vcfpath )
metainf = aggregate_META_information(cm)
#' Aggregate required information from VCF comment section
#'
#' @param comment_section
#'
#' @return
#' @export
#'
#' @examples
aggregate_META_information = function(comment_section){
analysis_name = pull_comment_value(comment_section, stringoi = 'IonReporterAnalysisName')
vcf_path = pull_comment_value(comment_section, stringoi = 'path_vcf')
vcf_path = basename(vcf_path)
meta_info = list(vcf_path = vcf_path,
IonReporter = list(AnalysisName = analysis_name,
fileDate = pull_comment_value(comment_section,
stringoi = 'fileDate'),
fileUTCtime = pull_comment_value(comment_section,
stringoi = 'fileUTCtime'),
Software_version = pull_comment_value(comment_section,
stringoi = 'IonReporterSoftwareVersion'),
Export_version = pull_comment_value(comment_section,
stringoi = 'IonReporterExportVersion'),
reference = pull_comment_value(comment_section,
stringoi = 'reference'),
Workflow_version = pull_comment_value(comment_section,
stringoi = 'IonReporterWorkflowVersion'),
WorkflowName = pull_comment_value(comment_section,
stringoi = 'IonReporterWorkflowName')),
SampleInfo = list(disease = pull_comment_value(comment_section,
stringoi = 'sampleDiseaseType'),
tumor_cellularity_manual = pull_comment_value(comment_section,
stringoi = 'manually_input_percent_tumor_cellularity'),
tumor_cellularity_calculated = pull_comment_value(comment_section,
stringoi = 'calculated_tumor_cellularity')),
SequencingQC = list(percent_aligned_reads = pull_comment_value(comment_section,
stringoi = 'percent_aligned_reads'),
percent_non_zero_amplicons = pull_comment_value(comment_section,
stringoi = 'percent_non_zero_amplicons'),
total_read_count = pull_comment_value(comment_section, stringoi = 'total_read_count'),
median_reads_per_amplicon = pull_comment_value(comment_section,
stringoi = 'median_reads_per_amplicon'),
MAPD = pull_comment_value(comment_section,
stringoi = 'mapd'),
deamination_metric = pull_comment_value(comment_section,
stringoi = 'deamination_metric'))
)
return(meta_info)
}
# COMMENT SECTION
cm = vcf_comment_section(vcfpath = vcfpath )
metainf = aggregate_META_information(cm)
## Output files
if(nrow(vcf) > 0){
readr::write_tsv(vcf, file = filepaths$path_file_complete)
}
## Retrieve dirname and generate filepaths
filepaths = generate_paths(vcfpath = vcfpath)
## Output files
if(nrow(vcf) > 0){
readr::write_tsv(vcf, file = filepaths$path_file_complete)
}
if(nrow(snv) > 0){
readr::write_tsv(snv, file = filepaths$path_file_snv)
}
if(nrow(cnv_rows) > 0){
readr::write_tsv(cnv_rows, file = filepaths$path_file_cnv)
}
write_out_META_information(metainf, filename = filepaths$path_file_info)
filepath_df = data.frame(file = names(filepaths),
filepath  = unlist(unname(filepaths)))
filepaths
readr::write_tsv(filepath_df, filepaths$path_filepath)
sapply(unlist(unname(filepaths)), file.exists)
all(sapply(unlist(unname(filepaths)), file.exists))
sapply(unlist(unname(filepaths)), file.exists)
## Output files
if(nrow(vcf) > 0){
readr::write_tsv(vcf, file = filepaths$path_file_complete)
}
all(sapply(unlist(unname(filepaths)), file.exists))
sapply(unlist(unname(filepaths)), file.exists)
metainf
sample_id = metainf$vcf_path
sample_id
attach_ID = function(dataframe_oi){
dataframe_oi$sample_id = sample_id
return(dataframe_oi)
}
attach_ID = function(dataframe_oi, sample_id){
dataframe_oi$sample_id = sample_id
return(dataframe_oi)
}
## Output files
if(nrow(vcf) > 0){
vcf = attach_ID(vcf, sample_id = sample_id)
readr::write_tsv(vcf, file = filepaths$path_file_complete)
}
if(nrow(snv) > 0){
snv = attach_ID(snv, sample_id = sample_id)
readr::write_tsv(snv, file = filepaths$path_file_snv)
}
if(nrow(cnv_rows) > 0){
cnv_rows = attach_ID(cnv_rows, sample_id = sample_id)
readr::write_tsv(cnv_rows, file = filepaths$path_file_cnv)
}
cnv_rows
metainf
attach_ID = function(dataframe_oi, sample_id, analysis_name){
dataframe_oi$sample_id = sample_id
dataframe_oi$analysis_name = analysis_name
return(dataframe_oi)
}
analysis_name
analysis_name = metainf$IonReporter$AnalysisName
filepath_df
filepaths
lapply(filepaths, function(x) x)
lapply(filepaths, function(x) ifelse(file.exists(x), x, NA)
filepath_df = data.frame(file = names(filepaths),
lapply(filepaths, function(x) ifelse(file.exists(x), x, NA))
filepaths = lapply(filepaths, function(x) ifelse(file.exists(x), x, NA))
filepaths
filepath_df = data.frame(file = names(filepaths),
filepath  = unlist(unname(filepaths)))
filepath_df = attach_ID(filepath_df, sample_id = sample_id, analysis_name = analysis_name)
filepath_df
filepaths = generate_paths(vcfpath = vcfpath)
## Read in file
vcf = VCFparse::readVCF(vcfpath)
# Parse FUNC
if(nrow(vcf) > 0){
vcf = combine_orig_with_FUNC_extracts(vcf)
}
## remove double columns
vcf =  dplyr::select(vcf, -contains(".1"))
vcf =  dplyr::select(vcf, -FUNC)
# Generate tables
vcf$variant_type = gsub("[^[:alnum:] ]", "", vcf$variant_type)
vcf$protein = gsub("\\[|\\]", "", vcf$protein)
vcf$transcript = gsub("\\[|\\]", "", vcf$transcript)
vcf = dplyr::relocate(vcf, rowid)
# SNV table
snv = dplyr::filter(vcf, variant_type != 'synonymous' & alt != "<CNV>")
## Remove zero AF entries, especially important for Genexus
if("AF" %in% colnames(snv)){
snv = dplyr::filter(snv, AF != 0)
}
snv = dplyr::relocate(snv, rowid)
#   dplyr::mutate_all(as.character) |>
# tibble::as_tibble(vcf) |>
#   tidyr::pivot_longer(-gene)|>
#   dplyr::filter(grepl("\\[", value)) |>
#   dplyr::filter(name != 'FUNC')
# CNV entries only
cnv_rows = dplyr::filter(vcf, alt == "<CNV>")
if(nrow(cnv_rows) > 0){
cnv_rows = cnv_parse(cnv_rows)
cnv_rows = dplyr::select(cnv_rows, -origPos)
cnv_rows = dplyr::arrange(cnv_rows, desc(RAW_CN))
}
# COMMENT SECTION
cm = vcf_comment_section(vcfpath = vcfpath )
metainf = aggregate_META_information(cm)
vcf_file = metainf$vcf_path
analysis_name = metainf$IonReporter$AnalysisName
## Output files
if(nrow(vcf) > 0){
vcf = attach_ID(vcf, vcf_file = vcf_file, analysis_name = analysis_name)
readr::write_tsv(vcf, file = filepaths$path_file_complete)
}
#' Attach sample ID from original vcf path and analysis name to output dataframes.
#' These entries serve as unique identifiers across tables
#' @param dataframe_oi
#' @param sample_id
#' @param analysis_name
#'
#' @return
#' @export
#'
#' @examples
attach_ID = function(dataframe_oi, vcf_file, analysis_name){
dataframe_oi$vcf_file = vcf_file
dataframe_oi$analysis_name = analysis_name
return(dataframe_oi)
}
filepaths = generate_paths(vcfpath = vcfpath)
## Read in file
vcf = VCFparse::readVCF(vcfpath)
# Parse FUNC
if(nrow(vcf) > 0){
vcf = combine_orig_with_FUNC_extracts(vcf)
}
## remove double columns
vcf =  dplyr::select(vcf, -contains(".1"))
vcf =  dplyr::select(vcf, -FUNC)
# Generate tables
vcf$variant_type = gsub("[^[:alnum:] ]", "", vcf$variant_type)
vcf$protein = gsub("\\[|\\]", "", vcf$protein)
vcf$transcript = gsub("\\[|\\]", "", vcf$transcript)
vcf = dplyr::relocate(vcf, rowid)
# SNV table
snv = dplyr::filter(vcf, variant_type != 'synonymous' & alt != "<CNV>")
## Remove zero AF entries, especially important for Genexus
if("AF" %in% colnames(snv)){
snv = dplyr::filter(snv, AF != 0)
}
snv = dplyr::relocate(snv, rowid)
#   dplyr::mutate_all(as.character) |>
# tibble::as_tibble(vcf) |>
#   tidyr::pivot_longer(-gene)|>
#   dplyr::filter(grepl("\\[", value)) |>
#   dplyr::filter(name != 'FUNC')
# CNV entries only
cnv_rows = dplyr::filter(vcf, alt == "<CNV>")
if(nrow(cnv_rows) > 0){
cnv_rows = cnv_parse(cnv_rows)
cnv_rows = dplyr::select(cnv_rows, -origPos)
cnv_rows = dplyr::arrange(cnv_rows, desc(RAW_CN))
}
# COMMENT SECTION
cm = vcf_comment_section(vcfpath = vcfpath )
metainf = aggregate_META_information(cm)
vcf_file = metainf$vcf_path
analysis_name = metainf$IonReporter$AnalysisName
## Output files
if(nrow(vcf) > 0){
vcf = attach_ID(vcf, vcf_file = vcf_file, analysis_name = analysis_name)
readr::write_tsv(vcf, file = filepaths$path_file_complete)
}
if(nrow(snv) > 0){
snv = attach_ID(snv, vcf_file = vcf_file, analysis_name = analysis_name)
readr::write_tsv(snv, file = filepaths$path_file_snv)
}
if(nrow(cnv_rows) > 0){
cnv_rows = attach_ID(cnv_rows, vcf_file = vcf_file, analysis_name = analysis_name)
readr::write_tsv(cnv_rows, file = filepaths$path_file_cnv)
}
write_out_META_information(metainf, filename = filepaths$path_file_info)
filepaths = lapply(filepaths, function(x) ifelse(file.exists(x), x, NA))
filepath_df = data.frame(file = names(filepaths),
filepath  = unlist(unname(filepaths)))
filepath_df = attach_ID(filepath_df, vcf_file = vcf_file, analysis_name = analysis_name)
devtools::document()
getwd()
setwd(..)
setwd('..)
setwd('..')
devtools::create(VariantAnnotation)
devtools::create('VariantAnnotation)
devtools::create('VariantAnnotation')
vcffiles = list.files(path = "VCF", pattern = '*.vcf', recursive = TRUE, full.names = TRUE)
vcffiles = grep("/Variants/", vcffiles, value = TRUE, invert = TRUE)
vcffiles = grep("SmallVariants", vcffiles, value = TRUE, invert = TRUE)
vcffiles = grep("SolidTumor-Fusions", vcffiles, value = TRUE, invert = TRUE)
testfiles
testfiles = vcffiles[c(180:220)]
vcfpath = (testfiles[38])
vcfpath
## Retrieve dirname and generate filepaths
filepaths = generate_paths(vcfpath = vcfpath)
## VCFparse pipeline
library(VCFparse)
## Retrieve dirname and generate filepaths
filepaths = generate_paths(vcfpath = vcfpath)
## Read in file
vcf = VCFparse::readVCF(vcfpath)
# Parse FUNC
if(nrow(vcf) > 0){
vcf = combine_orig_with_FUNC_extracts(vcf)
}
## remove double columns
vcf =  dplyr::select(vcf, -contains(".1"))
vcf =  dplyr::select(vcf, -FUNC)
# Generate tables
vcf$variant_type = gsub("[^[:alnum:] ]", "", vcf$variant_type)
vcf$protein = gsub("\\[|\\]", "", vcf$protein)
vcf$transcript = gsub("\\[|\\]", "", vcf$transcript)
vcf = dplyr::relocate(vcf, rowid)
# SNV table
snv = dplyr::filter(vcf, variant_type != 'synonymous' & alt != "<CNV>")
## Remove zero AF entries, especially important for Genexus
if("AF" %in% colnames(snv)){
snv = dplyr::filter(snv, AF != 0)
}
snv = dplyr::relocate(snv, rowid)
# CNV entries only
cnv_rows = dplyr::filter(vcf, alt == "<CNV>")
if(nrow(cnv_rows) > 0){
cnv_rows = cnv_parse(cnv_rows)
cnv_rows = dplyr::select(cnv_rows, -origPos)
cnv_rows = dplyr::arrange(cnv_rows, desc(RAW_CN))
}
# COMMENT SECTION
cm = vcf_comment_section(vcfpath = vcfpath )
metainf = aggregate_META_information(cm)
vcf_file = metainf$vcf_path
analysis_name = metainf$IonReporter$AnalysisName
## Output files
if(nrow(vcf) > 0){
vcf = attach_ID(vcf, vcf_file = vcf_file, analysis_name = analysis_name)
readr::write_tsv(vcf, file = filepaths$path_file_complete)
}
if(nrow(snv) > 0){
snv = attach_ID(snv, vcf_file = vcf_file, analysis_name = analysis_name)
readr::write_tsv(snv, file = filepaths$path_file_snv)
}
if(nrow(cnv_rows) > 0){
cnv_rows = attach_ID(cnv_rows, vcf_file = vcf_file, analysis_name = analysis_name)
readr::write_tsv(cnv_rows, file = filepaths$path_file_cnv)
}
write_out_META_information(metainf, filename = filepaths$path_file_info)
library(yaml)
write_out_META_information(metainf, filename = filepaths$path_file_info)
filepaths = lapply(filepaths, function(x) ifelse(file.exists(x), x, NA))
filepath_df = data.frame(file = names(filepaths),
filepath  = unlist(unname(filepaths)))
filepath_df = attach_ID(filepath_df, vcf_file = vcf_file, analysis_name = analysis_name)
readr::write_tsv(filepath_df, filepaths$path_filepath)
ilepath_df
filepath_df
(testfiles[33])
(testfiles[12])
vcfpath = (testfiles[12])
## Retrieve dirname and generate filepaths
filepaths = generate_paths(vcfpath = vcfpath)
## Read in file
vcf = VCFparse::readVCF(vcfpath)
# Parse FUNC
if(nrow(vcf) > 0){
vcf = combine_orig_with_FUNC_extracts(vcf)
}
## remove double columns
vcf =  dplyr::select(vcf, -contains(".1"))
vcf =  dplyr::select(vcf, -FUNC)
# Generate tables
vcf$variant_type = gsub("[^[:alnum:] ]", "", vcf$variant_type)
vcf$protein = gsub("\\[|\\]", "", vcf$protein)
vcf$transcript = gsub("\\[|\\]", "", vcf$transcript)
vcf = dplyr::relocate(vcf, rowid)
# SNV table
snv = dplyr::filter(vcf, variant_type != 'synonymous' & alt != "<CNV>")
## Remove zero AF entries, especially important for Genexus
if("AF" %in% colnames(snv)){
snv = dplyr::filter(snv, AF != 0)
}
snv = dplyr::relocate(snv, rowid)
#   dplyr::mutate_all(as.character) |>
# tibble::as_tibble(vcf) |>
#   tidyr::pivot_longer(-gene)|>
#   dplyr::filter(grepl("\\[", value)) |>
#   dplyr::filter(name != 'FUNC')
# CNV entries only
cnv_rows = dplyr::filter(vcf, alt == "<CNV>")
if(nrow(cnv_rows) > 0){
cnv_rows = cnv_parse(cnv_rows)
cnv_rows = dplyr::select(cnv_rows, -origPos)
cnv_rows = dplyr::arrange(cnv_rows, desc(RAW_CN))
}
# COMMENT SECTION
cm = vcf_comment_section(vcfpath = vcfpath )
metainf = aggregate_META_information(cm)
vcf_file = metainf$vcf_path
analysis_name = metainf$IonReporter$AnalysisName
## Output files
if(nrow(vcf) > 0){
vcf = attach_ID(vcf, vcf_file = vcf_file, analysis_name = analysis_name)
readr::write_tsv(vcf, file = filepaths$path_file_complete)
}
if(nrow(snv) > 0){
snv = attach_ID(snv, vcf_file = vcf_file, analysis_name = analysis_name)
readr::write_tsv(snv, file = filepaths$path_file_snv)
}
if(nrow(cnv_rows) > 0){
cnv_rows = attach_ID(cnv_rows, vcf_file = vcf_file, analysis_name = analysis_name)
readr::write_tsv(cnv_rows, file = filepaths$path_file_cnv)
}
write_out_META_information(metainf, filename = filepaths$path_file_info)
filepaths = lapply(filepaths, function(x) ifelse(file.exists(x), x, NA))
filepath_df = data.frame(file = names(filepaths),
filepath  = unlist(unname(filepaths)))
filepath_df = attach_ID(filepath_df, vcf_file = vcf_file, analysis_name = analysis_name)
readr::write_tsv(filepath_df, filepaths$path_filepath)
filepath_df
readr::write_tsv(filepath_df, filepaths$path_filepath)
filepaths$path_filepath
## Retrieve dirname and generate filepaths
filepaths = generate_paths(vcfpath = vcfpath)
filepaths
filepaths$path_filepath
filepaths
filepaths[1:5] = lapply(filepaths[1:5], function(x) ifelse(file.exists(x), x, NA))
filepaths
filepath_df = data.frame(file = names(filepaths),
filepath  = unlist(unname(filepaths)))
filepath_df = attach_ID(filepath_df, vcf_file = vcf_file, analysis_name = analysis_name)
readr::write_tsv(filepath_df, filepaths$path_filepath)
vcfpath
